#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

const size_t max_buf_size = 2000;
const size_t max_args = 1000;
const int max_jobs = 150;

enum JOB_STATE {UNDEF = 0, BG, FG, ST};
struct Job {
    pid_t pid;                  // job PID
    int job_id;                 // job ID [1, 2, ...]
    int state;                  // UNDEF, BG, FG, ST
    char cmdline[max_buf_size]; // command line
};

struct Job job_list[max_jobs];  // The job list
char buffer[max_buf_size];

void prompt();
int buildin_cmd(char **argv);
void exec_pipe(char **argv, int idx, int argc);
void exec_command(char **argv, int argc);
void handle_sigtstp(int sig);  // the signal SIGSTP generated by Ctrl-Z
void handle_sigint(int sig);  // the signal SIGINT generated by Ctrl-C
void handle_sigchld(int sig);
int is_exist_suspended_jobs(struct Job *job_list);
int is_exist_the_suspended_job(struct Job *job_list, int job_id);
void initjobs(struct Job *job_list);
int maxjid(struct Job *job_list);
void wait_fg(pid_t pid);
void list_jobs(struct Job *job_list);
int add_job(struct Job *job_list, pid_t pid, int state, char *cmdline);
void clear_job(struct Job *job);
pid_t fg_pid(struct Job *job_list);  // return PID of current foreground job, 0 if no such job
struct Job* get_job_by_pid(struct Job* job_list, pid_t pid);
void delete_job(struct Job* job_list, pid_t pid);
pid_t get_pid_by_jid(struct Job* job_list, int jid);

void prompt() {
    char path[max_buf_size];
    getcwd(path, max_buf_size);
    const char ch = '/';
    char *ret;
    ret = strrchr(path, ch);
    ret++;
    fprintf(stdout, "[nyush %s]$ ", ret);
    fflush(stdout);
}

int buildin_cmd(char **argv) {
    // jobs
    if (strcmp(argv[0], "jobs") == 0) {
        if (argv[1] != NULL) {
            fprintf(stderr, "%s", "Error: invalid command\n");
            fflush(stderr);
        } else {
            list_jobs(job_list);
        }
        return 1;
    }

    // fg
    if (strcmp(argv[0], "fg") == 0) {
        if (argv[1] == NULL || argv[2] != NULL) {  // fg is called with 0 or 2+ arguments
            fprintf(stderr, "%s", "Error: invalid command\n");
            fflush(stderr);
        } else if (!is_exist_the_suspended_job(job_list,
            atoi(argv[1]))) { // the job index does not exist
                              // in the list of currently suspended jobs
            fprintf(stderr, "%s", "Error: invalid job\n");
            fflush(stderr);
        } else {
            pid_t pid = get_pid_by_jid(job_list, atoi(argv[1]));
            kill(-pid, SIGCONT);
            struct Job *job = get_job_by_pid(job_list, pid);
            job->state = FG;
            wait_fg(pid);
        }
        return 1;
    }

    // check "cd" format
    if (strcmp(argv[0], "cd") == 0) {
        if (argv[1] == NULL || argv[2] != NULL) {  // check if arguments num 0 or 2+
            fprintf(stderr, "%s", "Error: invalid command\n");
            fflush(stderr);
        } else if (access(argv[1], F_OK) == -1) {  // check exist or not
            fprintf(stderr, "%s", "Error: invalid directory\n");
            fflush(stderr);
        } else {
            chdir(argv[1]);
        }
        return 1;
    }

    return 0;
}

void exec_pipe(char **argv, int idx, int argc) {
    int p[2];
    pipe(p);

    if (fork() == 0) {
        dup2(p[1], STDOUT_FILENO);
        close(p[0]);
        close(p[1]);
        exec_command(argv, idx);
        exit(0);
    }
    if (fork() == 0) {
        dup2(p[0], STDIN_FILENO);
        close(p[0]);
        close(p[1]);
        exec_command(argv + idx + 1, argc - idx - 1);
        exit(0);
    }

    close(p[0]);
    close(p[1]);

    wait(0);
    wait(0);
}

void exec_command(char **argv, int argc) {
    // implement pipe
    for (int i = 0; i < argc; i++) {
        if (strcmp(argv[i], "|") == 0) {
            argv[i] = NULL;
            exec_pipe(argv, i, argc);
            exit(0);
        }
    }

    // implement I/O redirection
    int stdi, stdo;
    stdi = dup(STDIN_FILENO);
    stdo = dup(STDOUT_FILENO);
    int infg = -1, outfg = -1;
    for (int i = 0; argv[i] != NULL; i++) {
        if (strcmp(argv[i], "<") == 0) {  // check "<"
            argv[i] = NULL;
            if (argv[i + 1] == NULL) {
                fprintf(stderr, "%s", "Error: invalid command\n");
                fflush(stderr);
                exit(0);
            } else if (access(argv[i + 1], F_OK) == -1) {
                fprintf(stderr, "%s", "Error: invalid file\n");
                fflush(stderr);
                exit(0);
            } else {
                infg = open(argv[i + 1], O_RDONLY, 0666);
                dup2(infg, STDIN_FILENO);
                // break;
            }
        } else if (strcmp(argv[i], ">") == 0) {  // check ">"
            argv[i] = NULL;
            if (argv[i + 1] == NULL) {
                fprintf(stderr, "%s", "Error: invalid command\n");
                fflush(stderr);
                exit(0);
            } else {
                outfg = open(argv[i + 1], O_WRONLY | O_CREAT | O_TRUNC, 0666);
                dup2(outfg, STDOUT_FILENO);
                // break;
            }
        } else if (strcmp(argv[i], ">>") == 0) {  // check ">>"
            argv[i] = NULL;
            if (argv[i + 1] == NULL) {
                fprintf(stderr, "%s", "Error: invalid command\n");
                fflush(stderr);
                exit(0);
            } else {
                outfg = open(argv[i + 1], O_WRONLY | O_CREAT | O_APPEND, 0666);
                dup2(outfg, STDOUT_FILENO);
                // break;
            }
        }
    }

    execvp(argv[0], argv);

    if (infg != -1) {
        close(infg);
        dup2(stdi, STDIN_FILENO);
    }
    
    if (outfg != -1) {
        close(outfg);
        dup2(stdo, STDOUT_FILENO);
    }
}

void handle_sigtstp(int sig) {
    sigset_t mask, prev;
    sigfillset(&mask);
    sigprocmask(SIG_SETMASK, &mask, &prev);
    pid_t pid = fg_pid(job_list);
    if (pid == 0) return;
    sigprocmask(SIG_SETMASK, &prev, NULL);
    kill(-(pid), SIGTSTP);
}

void handle_sigint(int sig) {
    sigset_t mask, prev;
    sigfillset(&mask);
    sigprocmask(SIG_SETMASK, &mask, &prev);
    pid_t pid = fg_pid(job_list);
    if (pid == 0) return;
    sigprocmask(SIG_SETMASK, &prev, NULL);
    kill(-(pid), SIGINT);
}

void handle_sigchld(int sig) {
    pid_t pid;
    int status;
    sigset_t mask, prev;
    sigfillset(&mask);
    while((pid = waitpid(-1, &status, WNOHANG | WUNTRACED))  > 0) {
        sigprocmask(SIG_SETMASK, &mask, &prev);
        if (WIFEXITED(status)) {  // normal termination
            delete_job(job_list, pid);
        } else if (WIFSIGNALED(status)) {  // terminated because of the signal
            delete_job(job_list, pid);
        } else if (WIFSTOPPED(status)) {  // stopped because of the signal
            struct Job *job = get_job_by_pid(job_list, pid);
            job->state = ST;
        }
        sigprocmask(SIG_SETMASK, &prev, NULL);
    }
}

int is_exist_suspended_jobs(struct Job *job_list) {
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].pid != 0 && job_list[i].state == ST) {
            return 1;
        }
    }
    return 0;
}

int is_exist_the_suspended_job(struct Job *job_list, int job_id) {
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].job_id == job_id && job_list[i].state == ST) {
            return 1;
        }
    }
    return 0;  
}

void initjobs(struct Job *job_list) {
    for (int i = 0; i < max_jobs; i++) {
        clear_job(&job_list[i]);
    }
}

int maxjid(struct Job *job_list) {
    int max = -1;
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].job_id > max) {
            max = job_list[i].job_id;
        }
    }
    return max;
}

void wait_fg(pid_t pid) {
    sigset_t mask;
    sigemptyset(&mask);   
    while (fg_pid(job_list) != 0){
        sigsuspend(&mask);
    }
}

void list_jobs(struct Job *job_list) {
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].pid != 0) {
            fprintf(stdout, "[%d] %s\n", job_list[i].job_id, job_list[i].cmdline);
            // fprintf(stdout, "[%d] %s %d\n", job_list[i].job_id, job_list[i].cmdline, job_list[i].state);  // debug
            fflush(stdout);
        }
    }
}

int add_job(struct Job *job_list, pid_t pid, int state, char *cmdline) {
    if (pid < 1) return 0;
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].pid == 0) {
            job_list[i].pid = pid;
            job_list[i].state = state;
            job_list[i].job_id = i+1;
            strcpy(job_list[i].cmdline, cmdline);
            return 1;
        }
    }
    return 0;
}

void clear_job(struct Job *job) {
    job->pid = 0;
    job->job_id = 0;
    job->state = UNDEF;
    memset(job->cmdline, 0, max_buf_size);
}

pid_t fg_pid(struct Job *job_list) {
    int i;
    for (i = 0; i < max_jobs; i++) {
        if (job_list[i].state == FG) {
            return job_list[i].pid;
        }
    }
    return 0;
}

struct Job* get_job_by_pid(struct Job* job_list, pid_t pid) {
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].pid == pid) {
            return &job_list[i];
        }
    }
    return NULL;
}

void delete_job(struct Job* job_list, pid_t pid) {
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].pid == pid) {
            clear_job(&job_list[i]);
        }
    }
}

pid_t get_pid_by_jid(struct Job* job_list, int jid) {
    for (int i = 0; i < max_jobs; i++) {
        if (job_list[i].job_id == jid) {
            return job_list[i].pid;
        }
    }
    return 0;
}

int main() {
    signal(SIGTSTP, handle_sigtstp);
    signal(SIGINT,  handle_sigint);
    signal(SIGCHLD, handle_sigchld);  // terminated or stopped child
    
    initjobs(job_list);

    while (1) {
        prompt();

        // get input msg
        memset(buffer, 0, sizeof(char) * max_buf_size);
        fgets(buffer, max_buf_size - 1, stdin);
        if (buffer[0] == '\0') {
            exit(0);
        }
        if (buffer[0] == '\n') {
            continue;
        }

        // parse the command
        char *argv[max_args];
        memset(argv, 0, sizeof(char*) * max_args);
        int len = strlen(buffer);
        int i = 0, j = 0, argc = 0;
        while (i < len && buffer[i]) {
            while (i < len && strchr(" \t\r\n\v", buffer[i])) {  // skip whitespace
                i++;
            }
            if (i < len) {
                argv[j++] = buffer + i;
            }
            while (i < len && !strchr(" \t\r\n\v", buffer[i])) {  // skip token
                i++;
            }
            buffer[i++] = '\0';
        }
        argc = j;

        // check exit argument first
        if (strcmp(argv[0], "exit") == 0) {
            // check suspended jobs
            if (is_exist_suspended_jobs(job_list)) {
                fprintf(stderr, "%s", "Error: there are suspended jobs\n");
                fflush(stderr);
                continue;
            }
            // check arguments
            if (argv[1] != NULL) {
                fprintf(stderr, "%s", "Error: invalid command\n");
                fflush(stderr);
            } else {
                break;
            }
        }

        if (buildin_cmd(argv)) { continue; }

        pid_t pid;
        sigset_t mask_all, mask_one, prev_one;
        sigfillset(&mask_all);
        sigemptyset(&mask_one);
        sigaddset(&mask_one, SIGCHLD);
        sigprocmask(SIG_BLOCK, &mask_one, &prev_one);

        // child process execute command
        if ((pid = fork()) == 0) {
            sigprocmask(SIG_SETMASK, &prev_one, NULL);
            setpgid(0, 0);
            exec_command(argv, argc);
            exit(0);
        }

        sigprocmask(SIG_BLOCK, &mask_all, NULL);
        add_job(job_list, pid, FG, buffer);
        sigprocmask(SIG_SETMASK, &mask_one, NULL);
        wait_fg(pid);
        sigprocmask(SIG_SETMASK, &prev_one, NULL);
    }
    return 0;
}
